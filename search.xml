<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>Linux下的tar压缩解压缩命令详解</title>
      <url>/python/2018/07/04/tar/</url>
      <content type="text">tar

-c: 建立压缩档案
-x：解压
-t：查看内容
-r：向压缩归档文件末尾追加文件
-u：更新原压缩包中的文件

这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。

-z：有gzip属性的
-j：有bz2属性的
-Z：有compress属性的
-v：显示所有过程
-O：将文件解开到标准输出

下面的参数-f是必须的

-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。

 tar -cf all.tar *.jpg
这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。

 tar -rf all.tar *.gif
这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。

 tar -uf all.tar logo.gif
这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。

 tar -tf all.tar
这条命令是列出all.tar包中所有文件，-t是列出文件的意思

 tar -xf all.tar
这条命令是解出all.tar包中所有文件，-t是解开的意思

压缩

tar -cvf jpg.tar *.jpg //将目录里所 有jpg文件打包成jpg.tar

tar -czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz

tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2

tar -cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z

rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux

zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux

解压

tar -xvf file.tar //解压 tar包

tar -xzvf file.tar.gz //解压tar.gz

tar -xjvf file.tar.bz2   //解压 tar.bz2

tar -xZvf file.tar.Z   //解压tar.Z

unrar e file.rar //解压rar

unzip file.zip //解压zip

总结

1、*.tar 用 tar -xvf 解压

2、*.gz 用 gzip -d或者gunzip 解压

3、.tar.gz和.tgz 用 tar -xzf 解压

4、*.bz2 用 bzip2 -d或者用bunzip2 解压

5、*.tar.bz2用tar -xjf 解压

6、*.Z 用 uncompress 解压

7、*.tar.Z 用tar -xZf 解压

8、*.rar 用 unrar e解压

9、*.zip 用 unzip 解压
</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Python总结</title>
      <url>/python/2018/07/03/interview/</url>
      <content type="text">Python基础

基础语法


  
    a=a^b

    b=b^a

    a=a^b
  
  
    修改不可变类型 TypeError
  
  
    print 调用 sys.stdout.write方法
  
  
    小内存读取大文件：

    def get_lines():
    l=[]
    with open('file.txt','rb') as f:
        data = f.readlines(60000)
    l.append(data)
    yield l

    

    通过生成器，分多次读取，每次读取数量相对少的数据进行处理

    要考虑的问题： 分批读入数据要记录每次读入数据的位置；分批每次读入数据的大小，太小会在读取操作上耗费过多时间。
  
  
    read、readline、readlines的区别？

    read:读取整个文件

    readline:读取下一行，使用生成器方法

    readlines:读取整个文件到一个迭代器供我们遍历（可指定行数）
  
  
    linux

    
      这个函数接收文件夹的路径作为输入参数
      返回该文件夹中文件的路径
      以及其包含文件夹中文件的路径
    

    def print_directory_contents(sPath):
    import os
    for sChild in os.listdir(sPath):
        sChildPath = os.path.join(sPath,sChild)
        if os.path.isdir(sChildPath):
            print_directory_contents(sChildPath)
        else:
            print(sChildPath)

    
  
  
    常用的Python标准库：

    
      os
      time
      random
      pymysql
      threading
      multiprocessing
      queue
    
  
  
    浅拷贝（shallow copy）

    浅拷贝会创建新对象，其内容非原对象本身的引用，而是原对象内第一层对象的引用。

    浅拷贝有三种形式：

    
      
        切片操作: b=a[:] or b = [x for x in a]
      
      
        工厂模式: b=list(a)
      
      
        copy: b=copy.copy(a)
      
    
  
  
    os模块常见方法

    
      
        os.remove()
      
      
        os.rename()
      
      
        os.walk()
      
      
        os.chdir()
      
      
        os.mkdir/makedirs
      
      
        os.rmdir/removedirs
      
      
        os.listdir()
      
      
        os.getcwd()
      
      
        os.chmod()
      
      
        os.path.basename()
      
      
        os.path.dirname()
      
      
        os.path.join()
      
      
        os.path.split()
      
      
        os.path.getsize()
      
      
        os.path.exists()
      
      
        os.path.isabs()
      
      
        os.path.isdir()
      
      
        os.path.isfile()
      
    
  
  
    sys 常用方法

    
      sys.argv
      sys.modules.keys()
      sys.exc_info()
      sys.exit(n)
      sys.version
      sys.maxint
      sys.maxunicode
      sys.modules
      sys.path
      sys.platform
      sys.stdout
      sys.stdin
      sys.stderr
      sys.exc_clear
      sys.exec_prefix
      sys.byteorder
      sys.copyright
      sys.api_version
      sys.version_info
    
  
  
    Python 是强语言类型还是弱语言类型？

    Python 是强类型的动态脚本语言。

    强类型：不允许不同类型相加。

    动态：不使用显示数据类型声明，确定一个变量的类型是第一次给它赋值的时候。

    脚本语言： 一般也是解释性语言，运行代码只需要一个解释器，不需要编译。
  


</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
          <tag> 面试 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Python私有变量和私有方法总结</title>
      <url>/python/2018/07/03/Python%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/</url>
      <content type="text">&quot;&quot;&quot;
类的私有变量和私有方法
在Python中可以通过在属性变量名前加上双下划线定义属性为私有属性
特殊变量命名

1、 _xx 以单下划线开头的表示的是protected类型的变量。即保护类型只能允许其本身与子类进行访问。若内部变量标示，如： 当使用“from M import”时，不会将以一个下划线开头的对象引入 。

2、 __xx 双下划线的表示的是私有类型的变量。只能允许这个类本身进行访问了，连子类也不可以用于命名一个类属性（类变量），调用时名字被改变（在类FooBar内部，__boo变成_FooBar__boo,如self._FooBar__boo）

3、 __xx__定义的是特列方法。用户控制的命名空间内的变量或是属性，如init , __import__或是file 。只有当文档有说明时使用，不要自己定义这类变量。 （就是说这些是python内部定义的变量名）

在这里强调说一下私有变量,python默认的成员函数和成员变量都是公开的,没有像其他类似语言的public,private等关键字修饰.但是可以在变量前面加上两个下划线&quot;_&quot;,这样的话函数或变量就变成私有的.这是python的私有变量轧压(这个翻译好拗口),英文是(private name mangling.) **情况就是当变量被标记为私有后,在变量的前端插入类名,再类名前添加一个下划线&quot;_&quot;,即形成了_ClassName__变量名.**

Python内置类属性
__dict__ : 类的属性（包含一个字典，由类的数据属性组成）
__doc__ :类的文档字符串
__module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）
__bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）
&quot;&quot;&quot;

class pub():
    _name = 'protected类型的变量'
    __info = '私有类型的变量'
    def _func(self):
        print(&quot;这是一个protected类型的方法&quot;)
    def __func2(self):
        print('这是一个私有类型的方法')
    def get(self):
        return(self.__info)

a = pub()
print(a._name)
a._func()
# print(a.info)
# 执行结果：
# protected类型的变量
# 这是一个protected类型的方法

# protected类型的变量和方法 在类的实例中可以获取和调用

# # print(a.__info)
# # a.__func2()
# 执行结果：
#   File &quot;D:/Python/class/class3.py&quot;, line 46, in &amp;lt;module&amp;gt;
#     print(a.__info)
# # AttributeError: pub instance has no attribute '__info'
#     a.__func2()
# AttributeError: pub instance has no attribute '__func2'

# 私有类型的变量和方法 在类的实例中获取和调用不到

# 获取私有类型的变量

print(a.get())
# 执行结果：私有类型的变量
# 如果想要在实例中获取到类的私有类形变量可以通过在类中声明普通方法，返回私有类形变量的方式获取


print(dir(a))
# 执行结果：['__doc__', '__module__', '_func', '_name', '_pub__func2', '_pub__info', 'get']
print(a.__dict__)
# 执行结果：{}
print(a.__doc__)
# 执行结果： None
print(a.__module__)
# 执行结果：__main__
print(a.__bases__)
# 执行结果:
#     print(a.__bases__)
# AttributeError: pub instance has no attribute '__bases__'



</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>python中os/sys常用方法</title>
      <url>/python/2018/06/26/os%E5%92%8Csys/</url>
      <content type="text">sys模块提供了访问或操作与python解释器相关方法与对象。

几个常用到的动态对象：

sys.argv,这是一个列表，它包含了所有传递给脚本的命令行参数，其中第一个为脚本自身的名称；

sys.path 这也是一个列表，里面放了模块的搜索路经。并且呢，path[0]表示当脚本的路经。

sys.modules, 这是一个字典类型，它里面放了所有载入的模块。

sys.stdin , 标准输入流–一个类文件对象, raw_input()与input()这是使用它。

sys.stdout,标准输出流–一个类文件对象，我们使用print的时候，就是在使用它；

sys.stderr：标准错误流–一个类文件对象

（以上三个流对象都可以重定向到其它 的IO设备的。）

几个常用的静态对象：

sys.builtin_module_names: 这是一个元组，里面放的是python解释器的内置的所有模块名称。

sys.version ,存放了python解释器的版本信息。

sys.platform , 存放的是python解释器的平台，返回linux2或windows

常用到的函数：

exit([status])，退出，默认为0，表示正常退出。

对于os模块来说，首说一个通过os来调用的模块:os.path，它存在于os模块中，本身又是一个模块。os.path只是一个别名而已，对于不同的平台，这个模块可能有不同的名字。如，posix式的系统（如unix,linux)的话，它的别名就叫做os.path.对于Mac、windows等来说，可能名字叫做macpach, ntpath。

模块os.path下常见的函数：

abspath(path)：    Return an absolute path，返回绝对路经
basename(p)：     Returns the final component of a pathname：返回路经的最后一部分，即 最后一个 / 后的内容；

commonprefix(list)：    Given a list of pathnames, returns the longest common leading componen,它的输入为一个路经的列表，用于返回list中，所有path共有的最长的路径，从左向右，相同字符。

dirname(p)：   Returns the directory component of a pathname，返回目录哦；

exists(path)：    Test whether a path exists.  Returns False for broken symbolic links，测试一个目录是否存在；

expanduser(path)：    Expand ~ and ~user constructions.  If user or $HOME is unknown,do nothing.作用就是把目录中的~展开；

getatime(filename):  获得最后一次访问文件的时间，可以通过 os.stat()函数查看具体的状态；

getctime(filename):   返回元数据最后一次change的时间；

getmtime(filename):  返回最后一次修改的时间；

isabs(s)：      测试一个路经是否是绝对路经；

isdir(s) :        Return true if the pathname refers to an existing directory.

isfile(path):    Test whether a path is a regular file

join(path1[, path2[, …]])； 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略normcase(path): 在Linux下，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换 为反斜杠 splitdrive(path): 拆分驱动器名和路径，主要对win，对linux元组第一个总是空的 splitext(path): 分离文件名与扩展名；默认返回(fname,fextension)元组，可做分片操作 ，以“.”为分隔符 getsize(path): 返回path的大小（字节）

在os模块中，相关的函数太多了，只说几个有用的，如果想具体看，可以通过 help(‘os’)查看哦；

一些与平台相关的一些常量，平台一一样，返回的值也不一样；
     - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos' ，操作系统的名字；
     - os.curdir is a string representing the current directory ('.' or ':') 当前目录的表示；
     - os.pardir is a string representing the parent directory ('..' or '::') 父目录的表示；
     - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')目录名的分隔号；
     - os.extsep is the extension separator ('.' or '/') 名字与扩展名之间的分隔号；
     - os.altsep is the alternate pathname separator (None or '/') 
     - os.pathsep is the component separator used in $PATH etc 目录之间的分隔号，linux下为：。
     - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')一行的分隔号；
     - os.defpath is the default search path for executables，执行程序时的默认路经；linux下通常为bash的路经
     - os.devnull is the file path of the null device ('/dev/null', etc.) 空设备的文件路经；



一些常用函数：
os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径 
os.chdir(&quot;dirname&quot;) 改变当前脚本工作目录；相当于shell下cd
os.pardir 获取当前目录的父目录字符串名：('..')
os.makedirs('dirname1/dirname2') 可生成多层递归目录
os.removedirs('dirname1') 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
os.mkdir('dirname') 生成单级目录；相当于shell中mkdir dirname
os.rmdir('dirname') 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
os.listdir('dirname') 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove() 删除一个文件
os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录
os.stat('path/filename') 获取文件/目录信息
os.symlink('path/filename','ln_filename') 创建符号链接，源需绝对路径
os.utime() 修改时间属性
os.system(command) 函数用来运行shell命令：


</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
          <tag> 面试 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>火车票查询购票软件开发</title>
      <url>/python/2018/06/10/tickets/</url>
      <content type="text">6月13日
列车信息模块

  对车站名称、车站编号进行获取


通过分析12306查询响应找到jquery地址，构造正则表达式进行匹配获得字典

url = 'https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9055'
r = requests.get(url)
patter = u'([\u4e00-\u9fa5]+)\|([A-Z]+)' 	#unicode格式编码
result = dict(re.findall(patter, r.text))



对字典键值对进行拆分获得车站名称和车站简写两个列表，构造函数方便互相取值


  对得到的列车信息进行提取


trains = r.json()['data']['result']



构造好请求地址后返回json对象，通过上面的格式获取raw_trains

将参数、raw_trains 传入TrainCollection类里，进行下一步提取

将得到的raw_trains用split(‘|‘)分割，得到列车信息列表，对比12306的js文件得到需要的信息

如果满足参数要求，构造生成器，返回parse_train_data函数处理好后的列车信息

得到列车信息列表，返回给tkinter输出

车票价格模块

同样分析12306网站响应，发现票价查询有两个页面，一个是单独查询所有票价，需要输入验证码，另外一个是在列车信息界面点击通过ajax请求获得点击的这行列车各个坐席的价格，验证码放到登录界面攻破，所以选择第二种方式，构造jquery请求网址，导入threading 模块，一次性获得查询趟次所有列车价格。

难点在于构造请求网址，同样通过分析js文件后获得列表对应的编号，主要是每趟列车的始发站和到达站格式为int形式，不同于初始请求的车站缩写。

6月14日

解决价格获取问题

​	昨天的价格获取实现不太友好，只是在终端输出。考虑到需要gui接收，必须封装成列表返回。本来以为是个小功能，结果发现并不简单。

​	利用for循环创建多线程获取到每列车次的价格后需要添加到类属性列表中，首先排除掉join方法，因为GIL的问题，当车次过多时严重超时，等待时间过长，考虑lock互斥锁。为了能一次性返回整合好的价格列表和车次余票信息（两个列表），必须让主进程等待价格列表获取完全，引入self.train_num初始化为0，查询一次+1，循环判断当数量等于用户查询的车次类型的数量时，获取成功，return两个列表。

while 1:
    if len(self.prices) == self.train_num:
    	print('查询趟次:', len(self.prices))
    	return result, self.prices



综合对比过后，这是时间最短的一种方法，但当车次过多时等待时长还是较多。考虑tkinter实现多进程接收数据，让主菜单不至于卡死。

在开发到票价查询时，因为多次请求api，发现12306做了反爬机制会返回403错误，所以要完善查询功能还待进一步学习代理技术。

6月20日
近期总结

端午节过完了，后台程序也写得差不多了，写一下遇到的坑

排除了上次写的一次获取所有价格方案，（虽然多线程那里搞出来的时候还挺开心的，但是全部扔掉）决定在界面中实现用户点击单次列车进行价格查询，性能更高，程序更稳定。

登录模块


  
    验证码

    由于12306验证码过于变态，涉及到机器学习进行图片验证，所以直接请求验证码接口进行用户本地验证

    创建8个本地列表坐标，获取用户选择的图片后将构造好的坐标与用户名密码一起发送给登录接口
  
  
    登录验证

    用fiddler抓包，居然有f12获取不到的数据，发现12306对用户名密码有两次验证，

    用第一次请求https://kyfw.12306.cn/passport/web/auth/uamtk得到的apptk发送给https://kyfw.12306.cn/otn/uamauthclient,登录验证成功
  


订票购票模块


  
    订票功能

    登录查票之后点击预订按钮进行抓包分析，发现需要构造一个带sec字符串的json对象，这个sec串是在查询界面请求到的列车信息里的下标为0的元素，为了实现预订请求，把查询列车信息模块进行调整，传给界面的时候将整个分割后的data_list作为参数传递，方便订票时获取对应信息。

    这里还需要当日的日期，格式按照0000-00-00，所以用到了time模块下的strftime,localtime对time.time()进行格式化
  
  
    获取余票信息

    这一块考察对页面获取到的信息进行筛选能力，多处用到正则，

    其中余票数量让我最纠结，最后通过下列代码成功得到需要的数据

    ticket_num = re.findall(r&quot;\w+num\':\'[1-9]\d*\'&quot;, res)

    

    正则真的是，神器
  
  
    剩下的就是依次请求接口获取下个接口需要的数据，也没什么好写的
  


查询界面出来之后软件感觉瞬间成型了一半，这几天还有一点让我学习的是如何协调后台程序的参数和gui界面的显示，我把原来的函数封装了几个类，另外写了一个主函数用来对各个界面以及后台功能函数的互相调用，这样运行逻辑更清晰。

剩下的就是和界面加入主函数后互相进行调试。。。

To be continued… :runner:
</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>fluent python笔记</title>
      <url>/python/2018/06/07/fluntpython-note/</url>
      <content type="text">数据类型



bool
bool(x) 的背后是调用x.bool() 的结果；如果不存在 bool 方法，那么 bool(x) 会尝试调用 x.len()。若返回 0，则 bool 会返回 False；否则返回True。

bool&amp;gt; __bool__&amp;gt;__len__

collections.namedtuple
自 Python 2.6 开始，namedtuple 就加入到 Python 里，用以构建只有少数属性但是没有方法的对象，比如数据库条目。

序列数组



序列

容器序列

　　list、tuple 和 collections.deque 这些序列能存放不同类型的数据。

扁平序列

　　str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。

容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。

可变序列（仅限数组）

　　list、bytearray、array.array、collections.deque 和memoryview。

不可变序列

　　tuple、str 和 bytes。



关于迭代器和生成器：


  白话解释迭代器和生成器


迭代器：含__next__()

可迭代：含__iter__()

生成器：yield 或 ( 推导式 )

l=[0, 1, 20, 11, 5, 22, 9]

l[2:5] = 100 ➊

&amp;gt;  Traceback (most recent call last):File &quot;&quot;, line 1,
&amp;gt;  in*TypeError:can only assign an iterable


➊如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。

初始化多维列表

错误用法

 my_list = [[]] * 3

初始化得到同一个列表的引用*3

正确用法：

 l=[[''] * 3 for i in range(3)]

总结：注意对象的引用是否变化

关于序列的增量赋值运算

+= 类似于 *=

程序先调用__iadd__，如果没找到，就调用__add__方法，

！可变序列+=后，变量名不会被关联到新的对象，不可变序列因为不存在增量赋值运算，调用__add__后创建新变量赋值给原不可变序列。（str 是一个例外，因为对字符串做 += 实在是太普遍了，所以 CPython 对它做了优化。为 str初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作）

栗子：





元组
栗子：
 &amp;gt;&amp;gt;&amp;gt; t = (1, 2, [30, 40])

 &amp;gt;&amp;gt;&amp;gt; t[2] += [50, 60]


抛出异常同时修改t

总结：

1、不要把可变对象放在元组里面。

2、增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。

3、查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。

字典和集合

创建字典的不同方式：
&amp;gt;&amp;gt;&amp;gt; a = dict(one=1, two=2, three=3)

&amp;gt;&amp;gt;&amp;gt; b = {'one': 1, 'two': 2, 'three': 3}

&amp;gt;&amp;gt;&amp;gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))

&amp;gt;&amp;gt;&amp;gt; d = dict([('two', 2), ('one', 1), ('three', 3)])

&amp;gt;&amp;gt;&amp;gt; e = dict({'three': 3, 'one': 1, 'two': 2})

&amp;gt;&amp;gt;&amp;gt; a == b == c == d == e
True



减少字典查询次数：
这样写
my_dict.setdefault(key, []).append(new_value)

获取单词的出现情况列表，如果单词不存在，把单词和一个空列表放进映射，然后返回这个空列表，这样就能在不进行第二次查找的情况下更新列表了。

跟这样写：

if key not in my_dict:
    my_dict[key] = []
    my_dict[key].append(new_value)



二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用 setdefault 只需要一次就可以完成整个操作。

defaultdict
defaultdict 里的default_factory只会在__getitem__里被调用，在其他的方法里完全不会发挥作用。比如，dd 是个 defaultdict，k 是个找不到的键， dd[k] 这个表达式会调用 default_factory 的__getitem__ 方法创造某个默认值，而 dd.get(k) 则会返回 None。

__missing__

class StrKeyDict0(dict): ➊
    def __missing__(self, key):
        if isinstance(key, str): ➋
            raise KeyError(key)
        return self[str(key)] ➌
    def get(self, key, default=None):
        try:
            return self[key] ➍
        except KeyError:
            return default ➎
    def __contains__(self, key):
        return key in self.keys() or str(key) in self.keys() ➏


❶ StrKeyDict0 继承了 dict。
❷ 如果找不到的键本身就是字符串，那就抛出 KeyError 异常。
❸ 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。
❹ get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会。
❺ 如果抛出 KeyError，那么说明 __missing__ 也失败了，于是返回default。
❻ 先按照传入键的原本的值来查找（我们的映射类型中可能含有非字符串的键），如果没找到，再用 str() 方法把键转换成字符串再查找一次。

集合

像 {1, 2, 3} 这种字面量句法相比于构造方法（set([1, 2, 3])）要更快且更易读。后者的速度要慢一些

dict和set的背后

背后的散列表


  Python 里的 dict 和 set 的效率有多高？
  为什么它们是无序的？
  为什么并不是所有的 Python 对象都可以当作 dict 的键或 set 里的元素？
  为什么 dict 的键和 set 元素的顺序是跟据它们被添加的次序而定的，以及为什么在映射对象的生命周期中，这个顺序并不是一成不变的？
  为什么不应该在迭代循环 dict 或是 set 的同时往里添加元素？


散列表看不懂，以后再看

To be continued… :runner:
</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>ok</title>
      <url>/2018/06/07/ok/</url>
      <content type="text">我的猫在我的键盘上走了一圈tuniocxzubhlkn214890o0ihfclknaeopj*(y732iknhdvgpoanlkn214ijoxcvn,asdfklj314
舍不得删它

:ok_hand:

</content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 不容易 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Among School Children</title>
      <url>/python/2018/06/02/AmongSchoolChildren/</url>
      <content type="text">VI

Plato thought nature but a spume that plays

Upon a ghostly paradigm of things;

Solider Aristotle played the taws 

Upon the bottom of a king of kings;

World-famous golden-thighed Pythagoras 

Fingered upon a fiddle-stick or strings

What a star sang and careless Muses heard:

Old clothes upon old sticks to scare a bird.

</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
