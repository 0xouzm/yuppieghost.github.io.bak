<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>火车票查询系统开发</title>
      <url>/python/2018/06/10/tickets%E6%9F%A5%E8%AF%A2/</url>
      <content type="text">6月13日
列车信息模块

  对车站名称、车站编号进行获取


通过分析12306查询响应找到jquery地址，构造正则表达式进行匹配获得字典

url = 'https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9055'
r = requests.get(url)
patter = u'([\u4e00-\u9fa5]+)\|([A-Z]+)' 	#unicode格式编码
result = dict(re.findall(patter, r.text))



对字典键值对进行拆分获得车站名称和车站简写两个列表，构造函数方便互相取值


  对得到的列车信息进行提取


trains = r.json()['data']['result']



构造好请求地址后返回json对象，通过上面的格式获取raw_trains

将参数、raw_trains 传入TrainCollection类里，进行下一步提取

将得到的raw_trains用split(‘|‘)分割，得到列车信息列表，对比12306的js文件得到需要的信息

如果满足参数要求，构造生成器，返回parse_train_data函数处理好后的列车信息

得到列车信息列表，返回给tkinter输出

车票价格模块

同样分析12306网站响应，发现票价查询有两个页面，一个是单独查询所有票价，需要输入验证码，另外一个是在列车信息界面点击通过ajax请求获得点击的这行列车各个坐席的价格，验证码放到登录界面攻破，所以选择第二种方式，构造jquery请求网址，导入threading 模块，一次性获得查询趟次所有列车价格。

难点在于构造请求网址，同样通过分析js文件后获得列表对应的编号，主要是每趟列车的始发站和到达站格式为int形式，不同于初始请求的车站缩写。

6月14日

解决价格获取问题

​	昨天的价格获取实现不太友好，只是在终端输出。考虑到需要gui接收，必须封装成列表返回。本来以为是个小功能，结果发现并不简单。

​	利用for循环创建多线程获取到每列车次的价格后需要添加到类属性列表中，首先排除掉join方法，因为GIL的问题，当车次过多时严重超时，等待时间过长，考虑lock互斥锁。为了能一次性返回整合好的价格列表和车次余票信息（两个列表），必须让主进程等待价格列表获取完全，引入self.train_num初始化为0，查询一次+1，循环判断当数量等于用户查询的车次类型的数量时，获取成功，return两个列表。

while 1:
    if len(self.prices) == self.train_num:
    	print('查询趟次:', len(self.prices))
    	return result, self.prices



综合对比过后，这是时间最短的一种方法，但当车次过多时等待时长还是较多。考虑tkinter实现多进程接收数据，让主菜单不至于卡死。

在开发到票价查询时，因为多次请求api，发现12306做了反爬机制会返回403错误，所以要完善查询功能还待进一步学习代理技术。

To be continued… :runner:
</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>fluent python笔记</title>
      <url>/python/2018/06/07/fluntpython-note/</url>
      <content type="text">数据类型



bool
bool(x) 的背后是调用x.bool() 的结果；如果不存在 bool 方法，那么 bool(x) 会尝试调用 x.len()。若返回 0，则 bool 会返回 False；否则返回True。

bool&amp;gt; __bool__&amp;gt;__len__

collections.namedtuple
自 Python 2.6 开始，namedtuple 就加入到 Python 里，用以构建只有少数属性但是没有方法的对象，比如数据库条目。

序列数组



序列

容器序列

　　list、tuple 和 collections.deque 这些序列能存放不同类型的数据。

扁平序列

　　str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。

容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。

可变序列（仅限数组）

　　list、bytearray、array.array、collections.deque 和memoryview。

不可变序列

　　tuple、str 和 bytes。



关于迭代器和生成器：


  白话解释迭代器和生成器


迭代器：含__next__()

可迭代：含__iter__()

生成器：yield 或 ( 推导式 )

l=[0, 1, 20, 11, 5, 22, 9]

l[2:5] = 100 ➊

&amp;gt;  Traceback (most recent call last):File &quot;&quot;, line 1,
&amp;gt;  in*TypeError:can only assign an iterable


➊如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。

初始化多维列表

错误用法

 my_list = [[]] * 3

初始化得到同一个列表的引用*3

正确用法：

 l=[[''] * 3 for i in range(3)]

总结：注意对象的引用是否变化

关于序列的增量赋值运算

+= 类似于 *=

程序先调用__iadd__，如果没找到，就调用__add__方法，

！可变序列+=后，变量名不会被关联到新的对象，不可变序列因为不存在增量赋值运算，调用__add__后创建新变量赋值给原不可变序列。（str 是一个例外，因为对字符串做 += 实在是太普遍了，所以 CPython 对它做了优化。为 str初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作）

栗子：





元组
栗子：
 &amp;gt;&amp;gt;&amp;gt; t = (1, 2, [30, 40])

 &amp;gt;&amp;gt;&amp;gt; t[2] += [50, 60]


抛出异常同时修改t

总结：

1、不要把可变对象放在元组里面。

2、增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。

3、查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。

字典和集合

创建字典的不同方式：
&amp;gt;&amp;gt;&amp;gt; a = dict(one=1, two=2, three=3)

&amp;gt;&amp;gt;&amp;gt; b = {'one': 1, 'two': 2, 'three': 3}

&amp;gt;&amp;gt;&amp;gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))

&amp;gt;&amp;gt;&amp;gt; d = dict([('two', 2), ('one', 1), ('three', 3)])

&amp;gt;&amp;gt;&amp;gt; e = dict({'three': 3, 'one': 1, 'two': 2})

&amp;gt;&amp;gt;&amp;gt; a == b == c == d == e
True



减少字典查询次数：
这样写
my_dict.setdefault(key, []).append(new_value)

获取单词的出现情况列表，如果单词不存在，把单词和一个空列表放进映射，然后返回这个空列表，这样就能在不进行第二次查找的情况下更新列表了。

跟这样写：

if key not in my_dict:
    my_dict[key] = []
    my_dict[key].append(new_value)



二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用 setdefault 只需要一次就可以完成整个操作。

defaultdict
defaultdict 里的default_factory只会在__getitem__里被调用，在其他的方法里完全不会发挥作用。比如，dd 是个 defaultdict，k 是个找不到的键， dd[k] 这个表达式会调用 default_factory 的__getitem__ 方法创造某个默认值，而 dd.get(k) 则会返回 None。

__missing__

class StrKeyDict0(dict): ➊
    def __missing__(self, key):
        if isinstance(key, str): ➋
            raise KeyError(key)
        return self[str(key)] ➌
    def get(self, key, default=None):
        try:
            return self[key] ➍
        except KeyError:
            return default ➎
    def __contains__(self, key):
        return key in self.keys() or str(key) in self.keys() ➏


❶ StrKeyDict0 继承了 dict。
❷ 如果找不到的键本身就是字符串，那就抛出 KeyError 异常。
❸ 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。
❹ get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会。
❺ 如果抛出 KeyError，那么说明 __missing__ 也失败了，于是返回default。
❻ 先按照传入键的原本的值来查找（我们的映射类型中可能含有非字符串的键），如果没找到，再用 str() 方法把键转换成字符串再查找一次。

集合

像 {1, 2, 3} 这种字面量句法相比于构造方法（set([1, 2, 3])）要更快且更易读。后者的速度要慢一些

dict和set的背后

背后的散列表


  Python 里的 dict 和 set 的效率有多高？
  为什么它们是无序的？
  为什么并不是所有的 Python 对象都可以当作 dict 的键或 set 里的元素？
  为什么 dict 的键和 set 元素的顺序是跟据它们被添加的次序而定的，以及为什么在映射对象的生命周期中，这个顺序并不是一成不变的？
  为什么不应该在迭代循环 dict 或是 set 的同时往里添加元素？


散列表看不懂，以后再看

To be continued… :runner:
</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>ok</title>
      <url>/2018/06/07/ok/</url>
      <content type="text">我的猫在我的键盘上走了一圈tuniocxzubhlkn214890o0ihfclknaeopj*(y732iknhdvgpoanlkn214ijoxcvn,asdfklj314
舍不得删它

:ok_hand:

</content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 不容易 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Among School Children</title>
      <url>/python/2018/06/02/AmongSchoolChildren/</url>
      <content type="text">VI

Plato thought nature but a spume that plays

Upon a ghostly paradigm of things;

Solider Aristotle played the taws 

Upon the bottom of a king of kings;

World-famous golden-thighed Pythagoras 

Fingered upon a fiddle-stick or strings

What a star sang and careless Muses heard:

Old clothes upon old sticks to scare a bird.

</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
