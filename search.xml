<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>火车票查询系统开发</title>
      <url>/python/2018/06/10/tickets%E6%9F%A5%E8%AF%A2/</url>
      <content type="text">6月13日
列车信息模块

  对车站名称、车站编号进行获取


通过分析12306查询响应找到jquery地址，构造正则表达式进行匹配获得字典

url = 'https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9055'
r = requests.get(url)
patter = u'([\u4e00-\u9fa5]+)\|([A-Z]+)' 	#unicode格式编码
result = dict(re.findall(patter, r.text))



对字典键值对进行拆分获得车站名称和车站简写两个列表，构造函数方便互相取值


  对得到的列车信息进行提取


trains = r.json()['data']['result']



构造好请求地址后返回json对象，通过上面的格式获取raw_trains

将参数、raw_trains 传入TrainCollection类里，进行下一步提取

将得到的raw_trains用split(‘|‘)分割，得到列车信息列表，对比12306的js文件得到需要的信息

如果满足参数要求，构造生成器，返回parse_train_data函数处理好后的列车信息

得到列车信息列表，返回给tkinter输出

车票价格模块

同样分析12306网站响应，发现票价查询有两个页面，一个是单独查询所有票价，需要输入验证码，另外一个是在列车信息界面点击通过ajax请求获得点击的这行列车各个坐席的价格，验证码放到登录界面攻破，所以选择第二种方式，构造jquery请求网址，导入threading 模块，一次性获得查询趟次所有列车价格。

难点在于构造请求网址，同样通过分析js文件后获得列表对应的编号，主要是每趟列车的始发站和到达站格式为int形式，不同于初始请求的车站缩写。

源码

import requests
import urllib3
import stations
from threading import Thread

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class TrainCollection(object):
    headers = '车次 车站 时间 历时 商务座 一等座 二等座 高级软卧 软卧 动卧 硬卧 软座 硬座 无座 其他'.split()

    price_temp = (
        'https://kyfw.12306.cn/otn/leftTicket/'
        'queryTicketPrice?train_no={}&amp;amp;'
        'from_station_no={}&amp;amp;'
        'to_station_no={}&amp;amp;'
        'seat_types={}&amp;amp;'
        'train_date={}')

    def __init__(self, raw_trains, options, date):
        self.raw_trains = raw_trains
        self.options = options
        self.date = date

    def get_from_to_station_name(self, data_list):
        from_station_telecode = data_list[6]
        to_station_telecode = data_list[7]
        return &quot;\n&quot;.join([stations.get_name(from_station_telecode), stations.get_name(to_station_telecode)])

    def get_start_arrive_time(self, data_list):
        return '\n'.join([data_list[8], data_list[9]])

    def parse_train_data(self, data_list):
        # get_price(self, data_list)
        # print(data_list)
        return {
            &quot;station_train_code&quot;: data_list[3],
            &quot;from_to_station_name&quot;: self.get_from_to_station_name(data_list),
            &quot;start_arrive_time&quot;: self.get_start_arrive_time(data_list),
            &quot;lishi&quot;: data_list[10],
            &quot;business_class_seat&quot;: data_list[32] or '--',
            &quot;first_class_seat&quot;: data_list[31] or '--',
            &quot;second_class_seat&quot;: data_list[30] or '--',
            &quot;super_soft_sleep&quot;: data_list[21] or '--',
            &quot;soft_sleep&quot;: data_list[23] or '--',
            &quot;dong_sleep&quot;: data_list[33] or '--',
            &quot;hard_sleep&quot;: data_list[28] or '--',
            &quot;soft_seat&quot;: data_list[24] or '--',
            &quot;hard_seat&quot;: data_list[29] or '--',
            &quot;no_seat&quot;: data_list[26] or '--',
            &quot;other&quot;: data_list[22] or '--'
        }

    def need_print(self, data_list):
        station_train_code = data_list[3]
        initial = station_train_code[0].lower()
        return (not self.options or initial in self.options)

    @property
    def trains(self):

        def get_price():
            price_url = self.price_temp.format(data_list[2], data_list[16], data_list[17], data_list[-2], self.date)
            r_p = requests.get(price_url, verify=False)
            print(r_p.json()['data'])
            # price = r_p.json()['data']

        for train in self.raw_trains:
            data_list = train.split('|')

            if self.need_print(data_list):
                t = Thread(target=get_price)
                t.start()
                yield self.parse_train_data(data_list)

    def search_out(self):

        print(self.date)
        result = [self.headers]
        for train in self.trains:
            result.append([
                train[&quot;station_train_code&quot;],
                train[&quot;from_to_station_name&quot;],
                train[&quot;start_arrive_time&quot;],
                train[&quot;lishi&quot;],
                train[&quot;business_class_seat&quot;],
                train[&quot;first_class_seat&quot;],
                train[&quot;second_class_seat&quot;],
                train[&quot;super_soft_sleep&quot;],
                train[&quot;soft_sleep&quot;],
                train[&quot;dong_sleep&quot;],
                train[&quot;hard_sleep&quot;],
                train[&quot;soft_seat&quot;],
                train[&quot;hard_seat&quot;],
                train[&quot;no_seat&quot;],
                train[&quot;other&quot;]
            ])

        return result


class Cli(object):
    url_template = (
        'https://kyfw.12306.cn/otn/leftTicket/query?'
        'leftTicketDTO.train_date={}&amp;amp;'
        'leftTicketDTO.from_station={}&amp;amp;'
        'leftTicketDTO.to_station={}&amp;amp;'
        'purpose_codes=ADULT')

    def __init__(self, from_station, to_station, date, options={}):
        self.arguments = {'from_station': from_station, 'to_station': to_station}
        self.arguments.update(options)
        self.from_station = stations.get_telecode(self.arguments['from_station'])
        self.to_station = stations.get_telecode(self.arguments['to_station'])
        self.date = date
        self.check_arguments_validatity()
        self.options = ''.join([key for key, value in self.arguments.items() if value == 1])

    @property
    def request_url(self):
        return self.url_template.format(self.date, self.from_station, self.to_station)

    def check_arguments_validatity(self):
        try:
            if self.from_station is None or self.to_station is None:
                raise ValueError
        except:
            raise ValueError

    def run(self):
        r = requests.get(self.request_url, verify=False)
        trains = r.json()['data']['result']
        return TrainCollection(trains, self.options, self.date).search_out()

# Cli('北京','上海','2018-06-17').run()




To be continued… :runner:
</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>fluent python笔记</title>
      <url>/python/2018/06/07/fluntpython-note/</url>
      <content type="text">数据类型



bool
bool(x) 的背后是调用x.bool() 的结果；如果不存在 bool 方法，那么 bool(x) 会尝试调用 x.len()。若返回 0，则 bool 会返回 False；否则返回True。

bool&amp;gt; __bool__&amp;gt;__len__

collections.namedtuple
自 Python 2.6 开始，namedtuple 就加入到 Python 里，用以构建只有少数属性但是没有方法的对象，比如数据库条目。

序列数组



序列

容器序列

　　list、tuple 和 collections.deque 这些序列能存放不同类型的数据。

扁平序列

　　str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。

容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。

可变序列（仅限数组）

　　list、bytearray、array.array、collections.deque 和memoryview。

不可变序列

　　tuple、str 和 bytes。



关于迭代器和生成器：


  白话解释迭代器和生成器


迭代器：含__next__()

可迭代：含__iter__()

生成器：yield 或 ( 推导式 )

l=[0, 1, 20, 11, 5, 22, 9]

l[2:5] = 100 ➊

&amp;gt;  Traceback (most recent call last):File &quot;&quot;, line 1,
&amp;gt;  in*TypeError:can only assign an iterable


➊如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。

初始化多维列表

错误用法

 my_list = [[]] * 3

初始化得到同一个列表的引用*3

正确用法：

 l=[[''] * 3 for i in range(3)]

总结：注意对象的引用是否变化

关于序列的增量赋值运算

+= 类似于 *=

程序先调用__iadd__，如果没找到，就调用__add__方法，

！可变序列+=后，变量名不会被关联到新的对象，不可变序列因为不存在增量赋值运算，调用__add__后创建新变量赋值给原不可变序列。（str 是一个例外，因为对字符串做 += 实在是太普遍了，所以 CPython 对它做了优化。为 str初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作）

栗子：





元组
栗子：
 &amp;gt;&amp;gt;&amp;gt; t = (1, 2, [30, 40])

 &amp;gt;&amp;gt;&amp;gt; t[2] += [50, 60]


抛出异常同时修改t

总结：

1、不要把可变对象放在元组里面。

2、增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。

3、查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。

字典和集合

创建字典的不同方式：
&amp;gt;&amp;gt;&amp;gt; a = dict(one=1, two=2, three=3)

&amp;gt;&amp;gt;&amp;gt; b = {'one': 1, 'two': 2, 'three': 3}

&amp;gt;&amp;gt;&amp;gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))

&amp;gt;&amp;gt;&amp;gt; d = dict([('two', 2), ('one', 1), ('three', 3)])

&amp;gt;&amp;gt;&amp;gt; e = dict({'three': 3, 'one': 1, 'two': 2})

&amp;gt;&amp;gt;&amp;gt; a == b == c == d == e
True



减少字典查询次数：
这样写
my_dict.setdefault(key, []).append(new_value)

获取单词的出现情况列表，如果单词不存在，把单词和一个空列表放进映射，然后返回这个空列表，这样就能在不进行第二次查找的情况下更新列表了。

跟这样写：

if key not in my_dict:
    my_dict[key] = []
    my_dict[key].append(new_value)



二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用 setdefault 只需要一次就可以完成整个操作。

defaultdict
defaultdict 里的default_factory只会在__getitem__里被调用，在其他的方法里完全不会发挥作用。比如，dd 是个 defaultdict，k 是个找不到的键， dd[k] 这个表达式会调用 default_factory 的__getitem__ 方法创造某个默认值，而 dd.get(k) 则会返回 None。

__missing__

class StrKeyDict0(dict): ➊
    def __missing__(self, key):
        if isinstance(key, str): ➋
            raise KeyError(key)
        return self[str(key)] ➌
    def get(self, key, default=None):
        try:
            return self[key] ➍
        except KeyError:
            return default ➎
    def __contains__(self, key):
        return key in self.keys() or str(key) in self.keys() ➏


❶ StrKeyDict0 继承了 dict。
❷ 如果找不到的键本身就是字符串，那就抛出 KeyError 异常。
❸ 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。
❹ get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会。
❺ 如果抛出 KeyError，那么说明 __missing__ 也失败了，于是返回default。
❻ 先按照传入键的原本的值来查找（我们的映射类型中可能含有非字符串的键），如果没找到，再用 str() 方法把键转换成字符串再查找一次。

集合

像 {1, 2, 3} 这种字面量句法相比于构造方法（set([1, 2, 3])）要更快且更易读。后者的速度要慢一些

dict和set的背后

背后的散列表


  
    Python 里的 dict 和 set 的效率有多高？
  
  为什么它们是无序的？
  为什么并不是所有的 Python 对象都可以当作 dict 的键或 set 里的元素？
  为什么 dict 的键和 set 元素的顺序是跟据它们被添加的次序而定的，以及为什么在映射对象的生命周期中，这个顺序并不是一成不变的？
  为什么不应该在迭代循环 dict 或是 set 的同时往里添加元素？


散列表看不懂，以后再看

To be continued… :runner:
</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>ok</title>
      <url>/2018/06/07/ok/</url>
      <content type="text">我的猫在我的键盘上走了一圈tuniocxzubhlkn214890o0ihfclknaeopj*(y732iknhdvgpoanlkn214ijoxcvn,asdfklj314
舍不得删它

:ok_hand:

</content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 不容易 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Among School Children</title>
      <url>/python/2018/06/02/AmongSchoolChildren/</url>
      <content type="text">VI

Plato thought nature but a spume that plays

Upon a ghostly paradigm of things;

Solider Aristotle played the taws 

Upon the bottom of a king of kings;

World-famous golden-thighed Pythagoras 

Fingered upon a fiddle-stick or strings

What a star sang and careless Muses heard:

Old clothes upon old sticks to scare a bird.

</content>
      <categories>
        
          <category> python </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
