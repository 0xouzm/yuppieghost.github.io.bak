<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-06-11T14:05:15+08:00</updated><id>http://localhost:4000/</id><title type="html">By WUJIAJING</title><subtitle>Because it is there.</subtitle><author><name>WUJIAJING</name></author><entry><title type="html">fluent python笔记</title><link href="http://localhost:4000/python/2018/06/07/fluntpython-note/" rel="alternate" type="text/html" title="fluent python笔记" /><published>2018-06-07T08:14:39+08:00</published><updated>2018-06-07T08:14:39+08:00</updated><id>http://localhost:4000/python/2018/06/07/fluntpython-note</id><content type="html" xml:base="http://localhost:4000/python/2018/06/07/fluntpython-note/">&lt;h1 id=&quot;第一章-数据类型&quot;&gt;第一章 数据类型&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;1.bool(x) 的背后是调用x.&lt;strong&gt;bool&lt;/strong&gt;() 的结果；如果不存在 &lt;strong&gt;bool&lt;/strong&gt; 方法，那么 bool(x) 会尝试调用 x.&lt;strong&gt;len&lt;/strong&gt;()。若返回 0，则 bool 会返回 False；否则返回True。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;bool&amp;gt; __bool__&amp;gt;__len__&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;2.自 Python 2.6 开始，namedtuple 就加入到 Python 里，用以构建只有少数属性但是没有方法的对象，比如数据库条目。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collections.namedtuple&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;第二章-序列数组&quot;&gt;第二章 序列数组&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;p&gt;容器序列&lt;/p&gt;

&lt;p&gt;　　list、tuple 和 collections.deque 这些序列能存放不同类型的数据。&lt;/p&gt;

&lt;p&gt;扁平序列&lt;/p&gt;

&lt;p&gt;　　str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。&lt;/p&gt;

&lt;p&gt;容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。&lt;/p&gt;

&lt;p&gt;可变序列（仅限数组）&lt;/p&gt;

&lt;p&gt;　　list、bytearray、array.array、collections.deque 和memoryview。&lt;/p&gt;

&lt;p&gt;不可变序列&lt;/p&gt;

&lt;p&gt;　　tuple、str 和 bytes。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/12502239-64aa498350f3f65a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.关于迭代器和生成器：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://segmentfault.com/a/1190000007208388&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;迭代器：含__next__()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;可迭代：含__iter__()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;生成器：yield 或 ( 推导式 )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;l=[0, 1, 20, 11, 5, 22, 9]

l[2:5] = 100 ➊

&amp;gt;  Traceback (most recent call last):File &quot;&quot;, line 1,
&amp;gt;  in*TypeError:can only assign an iterable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;➊如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。&lt;/p&gt;

&lt;p&gt;3.初始化多维列表&lt;/p&gt;

&lt;p&gt;错误用法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; my_list = [[]] * 3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;初始化得到同一个列表的引用*3&lt;/p&gt;

&lt;p&gt;正确用法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; l=[[''] * 3 for i in range(3)]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;总结：注意对象的引用是否变化&lt;/p&gt;

&lt;p&gt;4.关于序列的增量赋值运算&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;+=&lt;/strong&gt; 类似于 &lt;strong&gt;*=&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;程序先调用__iadd__，如果没找到，就调用__add__方法，&lt;/p&gt;

&lt;p&gt;！可变序列+=后，变量名不会被关联到新的对象，不可变序列因为不存在增量赋值运算，调用__add__后创建新变量赋值给原不可变序列。（str 是一个例外，因为对字符串做 += 实在是太普遍了，所以 CPython 对它做了优化。为 str初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作）&lt;/p&gt;

&lt;p&gt;栗子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/12502239-7efb570c5a3e337e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/12502239-770fd0c03a1d66f2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.栗子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;gt;&amp;gt;&amp;gt; t = (1, 2, [30, 40])

 &amp;gt;&amp;gt;&amp;gt; t[2] += [50, 60]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;抛出异常同时修改t&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、不要把可变对象放在元组里面。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;第三章-字典&quot;&gt;第三章 字典&lt;/h1&gt;

&lt;p&gt;1.创建字典的不同方式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = dict(one=1, two=2, three=3)

&amp;gt;&amp;gt;&amp;gt; b = {'one': 1, 'two': 2, 'three': 3}

&amp;gt;&amp;gt;&amp;gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))

&amp;gt;&amp;gt;&amp;gt; d = dict([('two', 2), ('one', 1), ('three', 3)])

&amp;gt;&amp;gt;&amp;gt; e = dict({'three': 3, 'one': 1, 'two': 2})

&amp;gt;&amp;gt;&amp;gt; a == b == c == d == e

True
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.减少字典查询次数：
这样写
&lt;code class=&quot;highlighter-rouge&quot;&gt;my_dict.setdefault(key, []).append(new_value)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;获取单词的出现情况列表，如果单词不存在，把单词和一个空列表放进映射，然后返回这个空列表，这样就能在不进行第二次查找的情况下更新列表了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;跟这样写：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if key not in my_dict:
my_dict[key] = []
my_dict[key].append(new_value)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用 setdefault 只需要一次就可以完成整个操作。&lt;/p&gt;

&lt;p&gt;3.defaultdict 里的default_factory只会在__getitem__里被调用，在其他的方法里完全不会发挥作用。比如，dd 是个 defaultdict，k 是个找不到的键， dd[k] 这个表达式会调用 default_factory 的__getitem__ 方法创造某个默认值，而 dd.get(k) 则会返回 None。&lt;/p&gt;

&lt;p&gt;4.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class StrKeyDict0(dict): ➊
    def __missing__(self, key):
        if isinstance(key, str): ➋
            raise KeyError(key)
        return self[str(key)] ➌
    def get(self, key, default=None):
        try:
            return self[key] ➍
        except KeyError:
            return default ➎
    def __contains__(self, key):
        return key in self.keys() or str(key) in self.keys() ➏
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;❶ StrKeyDict0 继承了 dict。
❷ 如果找不到的键本身就是字符串，那就抛出 KeyError 异常。
❸ 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。
❹ get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会。
❺ 如果抛出 KeyError，那么说明 __missing__ 也失败了，于是返回default。
❻ 先按照传入键的原本的值来查找（我们的映射类型中可能含有非字符串的键），如果没找到，再用 str() 方法把键转换成字符串再查找一次。&lt;/p&gt;</content><author><name>WUJIAJING</name></author><summary type="html">第一章 数据类型</summary></entry><entry><title type="html">总算弄好了</title><link href="http://localhost:4000/2018/06/07/day1/" rel="alternate" type="text/html" title="总算弄好了" /><published>2018-06-07T08:14:39+08:00</published><updated>2018-06-07T08:14:39+08:00</updated><id>http://localhost:4000/2018/06/07/day1</id><content type="html" xml:base="http://localhost:4000/2018/06/07/day1/">&lt;blockquote&gt;
  &lt;p&gt;我的猫在我的键盘上走了一圈…
舍不得删它&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>WUJIAJING</name></author><category term="不容易" /><summary type="html">我的猫在我的键盘上走了一圈… 舍不得删它</summary></entry></feed>