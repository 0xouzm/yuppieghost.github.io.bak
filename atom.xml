<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-06-27T19:29:44+08:00</updated><id>http://localhost:4000/</id><title type="html">By WUJIAJING</title><subtitle>Because it is there.</subtitle><author><name>WUJIAJING</name></author><entry><title type="html">python中os/sys常用方法</title><link href="http://localhost:4000/python/2018/06/26/os%E5%92%8Csys/" rel="alternate" type="text/html" title="python中os/sys常用方法" /><published>2018-06-26T03:25:39+08:00</published><updated>2018-06-26T03:25:39+08:00</updated><id>http://localhost:4000/python/2018/06/26/os%E5%92%8Csys</id><content type="html" xml:base="http://localhost:4000/python/2018/06/26/os%E5%92%8Csys/">&lt;h2 id=&quot;sys模块提供了访问或操作与python解释器相关方法与对象&quot;&gt;sys模块提供了访问或操作与python解释器相关方法与对象。&lt;/h2&gt;

&lt;h2 id=&quot;几个常用到的动态对象&quot;&gt;几个常用到的动态对象：&lt;/h2&gt;

&lt;p&gt;sys.argv,这是一个列表，它包含了所有传递给脚本的命令行参数，其中第一个为脚本自身的名称；&lt;/p&gt;

&lt;p&gt;sys.path 这也是一个列表，里面放了模块的搜索路经。并且呢，path[0]表示当脚本的路经。&lt;/p&gt;

&lt;p&gt;sys.modules, 这是一个字典类型，它里面放了所有载入的模块。&lt;/p&gt;

&lt;p&gt;sys.stdin , 标准输入流–一个类文件对象, raw_input()与input()这是使用它。&lt;/p&gt;

&lt;p&gt;sys.stdout,标准输出流–一个类文件对象，我们使用print的时候，就是在使用它；&lt;/p&gt;

&lt;p&gt;sys.stderr：标准错误流–一个类文件对象&lt;/p&gt;

&lt;p&gt;（以上三个流对象都可以重定向到其它 的IO设备的。）&lt;/p&gt;

&lt;h2 id=&quot;几个常用的静态对象&quot;&gt;几个常用的静态对象：&lt;/h2&gt;

&lt;p&gt;sys.builtin_module_names: 这是一个元组，里面放的是python解释器的内置的所有模块名称。&lt;/p&gt;

&lt;p&gt;sys.version ,存放了python解释器的版本信息。&lt;/p&gt;

&lt;p&gt;sys.platform , 存放的是python解释器的平台，返回linux2或windows&lt;/p&gt;

&lt;h2 id=&quot;常用到的函数&quot;&gt;常用到的函数：&lt;/h2&gt;

&lt;p&gt;exit([status])，退出，默认为0，表示正常退出。&lt;/p&gt;

&lt;p&gt;对于os模块来说，首说一个通过os来调用的模块:os.path，它存在于os模块中，本身又是一个模块。os.path只是一个别名而已，对于不同的平台，这个模块可能有不同的名字。如，posix式的系统（如unix,linux)的话，它的别名就叫做os.path.对于Mac、windows等来说，可能名字叫做macpach, ntpath。&lt;/p&gt;

&lt;h2 id=&quot;模块ospath下常见的函数&quot;&gt;模块os.path下常见的函数：&lt;/h2&gt;

&lt;p&gt;abspath(path)：    Return an absolute path，返回绝对路经
basename(p)：     Returns the final component of a pathname：返回路经的最后一部分，即 最后一个 / 后的内容；&lt;/p&gt;

&lt;p&gt;commonprefix(list)：    Given a list of pathnames, returns the longest common leading componen,它的输入为一个路经的列表，用于返回list中，所有path共有的最长的路径，从左向右，相同字符。&lt;/p&gt;

&lt;p&gt;dirname(p)：   Returns the directory component of a pathname，返回目录哦；&lt;/p&gt;

&lt;p&gt;exists(path)：    Test whether a path exists.  Returns False for broken symbolic links，测试一个目录是否存在；&lt;/p&gt;

&lt;p&gt;expanduser(path)：    Expand ~ and ~user constructions.  If user or $HOME is unknown,do nothing.作用就是把目录中的~展开；&lt;/p&gt;

&lt;p&gt;getatime(filename):  获得最后一次访问文件的时间，可以通过 os.stat()函数查看具体的状态；&lt;/p&gt;

&lt;p&gt;getctime(filename):   返回元数据最后一次change的时间；&lt;/p&gt;

&lt;p&gt;getmtime(filename):  返回最后一次修改的时间；&lt;/p&gt;

&lt;p&gt;isabs(s)：      测试一个路经是否是绝对路经；&lt;/p&gt;

&lt;p&gt;isdir(s) :        Return true if the pathname refers to an existing directory.&lt;/p&gt;

&lt;p&gt;isfile(path):    Test whether a path is a regular file&lt;/p&gt;

&lt;p&gt;join(path1[, path2[, …]])； 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略normcase(path): 在Linux下，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换 为反斜杠 splitdrive(path): 拆分驱动器名和路径，主要对win，对linux元组第一个总是空的 splitext(path): 分离文件名与扩展名；默认返回(fname,fextension)元组，可做分片操作 ，以“.”为分隔符 getsize(path): 返回path的大小（字节）&lt;/p&gt;

&lt;p&gt;在os模块中，相关的函数太多了，只说几个有用的，如果想具体看，可以通过 help(‘os’)查看哦；&lt;/p&gt;

&lt;h2 id=&quot;一些与平台相关的一些常量平台一一样返回的值也不一样&quot;&gt;一些与平台相关的一些常量，平台一一样，返回的值也不一样；&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos' ，操作系统的名字；
     - os.curdir is a string representing the current directory ('.' or ':') 当前目录的表示；
     - os.pardir is a string representing the parent directory ('..' or '::') 父目录的表示；
     - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')目录名的分隔号；
     - os.extsep is the extension separator ('.' or '/') 名字与扩展名之间的分隔号；
     - os.altsep is the alternate pathname separator (None or '/') 
     - os.pathsep is the component separator used in $PATH etc 目录之间的分隔号，linux下为：。
     - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')一行的分隔号；
     - os.defpath is the default search path for executables，执行程序时的默认路经；linux下通常为bash的路经
     - os.devnull is the file path of the null device ('/dev/null', etc.) 空设备的文件路经；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;一些常用函数&quot;&gt;一些常用函数：&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径 
os.chdir(&quot;dirname&quot;) 改变当前脚本工作目录；相当于shell下cd
os.pardir 获取当前目录的父目录字符串名：('..')
os.makedirs('dirname1/dirname2') 可生成多层递归目录
os.removedirs('dirname1') 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
os.mkdir('dirname') 生成单级目录；相当于shell中mkdir dirname
os.rmdir('dirname') 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
os.listdir('dirname') 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove() 删除一个文件
os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录
os.stat('path/filename') 获取文件/目录信息
os.symlink('path/filename','ln_filename') 创建符号链接，源需绝对路径
os.utime() 修改时间属性
os.system(command) 函数用来运行shell命令：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>WUJIAJING</name></author><category term="面试" /><summary type="html">sys模块提供了访问或操作与python解释器相关方法与对象。 几个常用到的动态对象： sys.argv,这是一个列表，它包含了所有传递给脚本的命令行参数，其中第一个为脚本自身的名称； sys.path 这也是一个列表，里面放了模块的搜索路经。并且呢，path[0]表示当脚本的路经。 sys.modules, 这是一个字典类型，它里面放了所有载入的模块。 sys.stdin , 标准输入流–一个类文件对象, raw_input()与input()这是使用它。 sys.stdout,标准输出流–一个类文件对象，我们使用print的时候，就是在使用它； sys.stderr：标准错误流–一个类文件对象 （以上三个流对象都可以重定向到其它 的IO设备的。） 几个常用的静态对象： sys.builtin_module_names: 这是一个元组，里面放的是python解释器的内置的所有模块名称。 sys.version ,存放了python解释器的版本信息。 sys.platform , 存放的是python解释器的平台，返回linux2或windows 常用到的函数： exit([status])，退出，默认为0，表示正常退出。 对于os模块来说，首说一个通过os来调用的模块:os.path，它存在于os模块中，本身又是一个模块。os.path只是一个别名而已，对于不同的平台，这个模块可能有不同的名字。如，posix式的系统（如unix,linux)的话，它的别名就叫做os.path.对于Mac、windows等来说，可能名字叫做macpach, ntpath。 模块os.path下常见的函数： abspath(path)： Return an absolute path，返回绝对路经 basename(p)： Returns the final component of a pathname：返回路经的最后一部分，即 最后一个 / 后的内容； commonprefix(list)： Given a list of pathnames, returns the longest common leading componen,它的输入为一个路经的列表，用于返回list中，所有path共有的最长的路径，从左向右，相同字符。 dirname(p)： Returns the directory component of a pathname，返回目录哦； exists(path)： Test whether a path exists. Returns False for broken symbolic links，测试一个目录是否存在； expanduser(path)： Expand ~ and ~user constructions. If user or $HOME is unknown,do nothing.作用就是把目录中的~展开； getatime(filename): 获得最后一次访问文件的时间，可以通过 os.stat()函数查看具体的状态； getctime(filename): 返回元数据最后一次change的时间； getmtime(filename): 返回最后一次修改的时间； isabs(s)： 测试一个路经是否是绝对路经； isdir(s) : Return true if the pathname refers to an existing directory. isfile(path): Test whether a path is a regular file join(path1[, path2[, …]])； 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略normcase(path): 在Linux下，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换 为反斜杠 splitdrive(path): 拆分驱动器名和路径，主要对win，对linux元组第一个总是空的 splitext(path): 分离文件名与扩展名；默认返回(fname,fextension)元组，可做分片操作 ，以“.”为分隔符 getsize(path): 返回path的大小（字节） 在os模块中，相关的函数太多了，只说几个有用的，如果想具体看，可以通过 help(‘os’)查看哦； 一些与平台相关的一些常量，平台一一样，返回的值也不一样； - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos' ，操作系统的名字； - os.curdir is a string representing the current directory ('.' or ':') 当前目录的表示； - os.pardir is a string representing the parent directory ('..' or '::') 父目录的表示； - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')目录名的分隔号； - os.extsep is the extension separator ('.' or '/') 名字与扩展名之间的分隔号； - os.altsep is the alternate pathname separator (None or '/') - os.pathsep is the component separator used in $PATH etc 目录之间的分隔号，linux下为：。 - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')一行的分隔号； - os.defpath is the default search path for executables，执行程序时的默认路经；linux下通常为bash的路经 - os.devnull is the file path of the null device ('/dev/null', etc.) 空设备的文件路经； 一些常用函数： os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径 os.chdir(&quot;dirname&quot;) 改变当前脚本工作目录；相当于shell下cd os.pardir 获取当前目录的父目录字符串名：('..') os.makedirs('dirname1/dirname2') 可生成多层递归目录 os.removedirs('dirname1') 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir('dirname') 生成单级目录；相当于shell中mkdir dirname os.rmdir('dirname') 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir('dirname') 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录 os.stat('path/filename') 获取文件/目录信息 os.symlink('path/filename','ln_filename') 创建符号链接，源需绝对路径 os.utime() 修改时间属性 os.system(command) 函数用来运行shell命令：</summary></entry><entry><title type="html">火车票查询购票软件开发</title><link href="http://localhost:4000/python/2018/06/10/tickets/" rel="alternate" type="text/html" title="火车票查询购票软件开发" /><published>2018-06-10T08:14:39+08:00</published><updated>2018-06-10T08:14:39+08:00</updated><id>http://localhost:4000/python/2018/06/10/tickets</id><content type="html" xml:base="http://localhost:4000/python/2018/06/10/tickets/">&lt;h2 id=&quot;6月13日&quot;&gt;6月13日&lt;/h2&gt;
&lt;h4 id=&quot;列车信息模块&quot;&gt;列车信息模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对车站名称、车站编号进行获取&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过分析12306查询响应找到jquery地址，构造正则表达式进行匹配获得字典&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9055'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;patter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u'([&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\u4e00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\u9fa5&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;]+)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;|([A-Z]+)'&lt;/span&gt; 	&lt;span class=&quot;c&quot;&gt;#unicode格式编码&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;patter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对字典键值对进行拆分获得车站名称和车站简写两个列表，构造函数方便互相取值&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对得到的列车信息进行提取&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;trains&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'result'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;构造好请求地址后返回json对象，通过上面的格式获取raw_trains&lt;/p&gt;

&lt;p&gt;将参数、raw_trains 传入TrainCollection类里，进行下一步提取&lt;/p&gt;

&lt;p&gt;将得到的raw_trains用split(‘|‘)分割，得到列车信息列表，对比12306的js文件得到需要的信息&lt;/p&gt;

&lt;p&gt;如果满足参数要求，构造生成器，返回parse_train_data函数处理好后的列车信息&lt;/p&gt;

&lt;p&gt;得到列车信息列表，返回给tkinter输出&lt;/p&gt;

&lt;h4 id=&quot;车票价格模块&quot;&gt;车票价格模块&lt;/h4&gt;

&lt;p&gt;同样分析12306网站响应，发现票价查询有两个页面，一个是单独查询所有票价，需要输入验证码，另外一个是在列车信息界面点击通过ajax请求获得点击的这行列车各个坐席的价格，验证码放到登录界面攻破，所以选择第二种方式，构造jquery请求网址，导入threading 模块，一次性获得查询趟次所有列车价格。&lt;/p&gt;

&lt;p&gt;难点在于构造请求网址，同样通过分析js文件后获得列表对应的编号，主要是每趟列车的始发站和到达站格式为int形式，不同于初始请求的车站缩写。&lt;/p&gt;

&lt;h2 id=&quot;6月14日&quot;&gt;6月14日&lt;/h2&gt;

&lt;h4 id=&quot;解决价格获取问题&quot;&gt;解决价格获取问题&lt;/h4&gt;

&lt;p&gt;​	昨天的价格获取实现不太友好，只是在终端输出。考虑到需要gui接收，必须封装成列表返回。本来以为是个小功能，结果发现并不简单。&lt;/p&gt;

&lt;p&gt;​	利用for循环创建多线程获取到每列车次的价格后需要添加到类属性列表中，首先排除掉join方法，因为GIL的问题，当车次过多时严重超时，等待时间过长，考虑lock互斥锁。为了能一次性返回整合好的价格列表和车次余票信息（两个列表），必须让主进程等待价格列表获取完全，引入self.train_num初始化为0，查询一次+1，循环判断当数量等于用户查询的车次类型的数量时，获取成功，return两个列表。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'查询趟次:'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prices&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;综合对比过后，这是时间最短的一种方法，但当车次过多时等待时长还是较多。考虑tkinter实现多进程接收数据，让主菜单不至于卡死。&lt;/p&gt;

&lt;p&gt;在开发到票价查询时，因为多次请求api，发现12306做了反爬机制会返回403错误，所以要完善查询功能还待进一步学习代理技术。&lt;/p&gt;

&lt;h2 id=&quot;6月20日&quot;&gt;6月20日&lt;/h2&gt;
&lt;h4 id=&quot;近期总结&quot;&gt;近期总结&lt;/h4&gt;

&lt;p&gt;端午节过完了，后台程序也写得差不多了，写一下遇到的坑&lt;/p&gt;

&lt;p&gt;排除了上次写的一次获取所有价格方案，（虽然多线程那里搞出来的时候还挺开心的，但是全部扔掉）决定在界面中实现用户点击单次列车进行价格查询，性能更高，程序更稳定。&lt;/p&gt;

&lt;h4 id=&quot;登录模块&quot;&gt;登录模块&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;验证码&lt;/p&gt;

    &lt;p&gt;由于12306验证码过于变态，涉及到机器学习进行图片验证，所以直接请求验证码接口进行用户本地验证&lt;/p&gt;

    &lt;p&gt;创建8个本地列表坐标，获取用户选择的图片后将构造好的坐标与用户名密码一起发送给登录接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;登录验证&lt;/p&gt;

    &lt;p&gt;用fiddler抓包，居然有f12获取不到的数据，发现12306对用户名密码有两次验证，&lt;/p&gt;

    &lt;p&gt;用第一次请求&lt;code class=&quot;highlighter-rouge&quot;&gt;https://kyfw.12306.cn/passport/web/auth/uamtk&lt;/code&gt;得到的apptk发送给&lt;code class=&quot;highlighter-rouge&quot;&gt;https://kyfw.12306.cn/otn/uamauthclient&lt;/code&gt;,登录验证成功&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;订票购票模块&quot;&gt;订票购票模块&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;订票功能&lt;/p&gt;

    &lt;p&gt;登录查票之后点击预订按钮进行抓包分析，发现需要构造一个带sec字符串的json对象，这个sec串是在查询界面请求到的列车信息里的下标为0的元素，为了实现预订请求，把查询列车信息模块进行调整，传给界面的时候将整个分割后的data_list作为参数传递，方便订票时获取对应信息。&lt;/p&gt;

    &lt;p&gt;这里还需要当日的日期，格式按照0000-00-00，所以用到了time模块下的strftime,localtime对time.time()进行格式化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取余票信息&lt;/p&gt;

    &lt;p&gt;这一块考察对页面获取到的信息进行筛选能力，多处用到正则，&lt;/p&gt;

    &lt;p&gt;其中余票数量让我最纠结，最后通过下列代码成功得到需要的数据&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ticket_num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;w+num&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;':&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'[1-9]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d*&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;正则真的是，神器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;剩下的就是依次请求接口获取下个接口需要的数据，也没什么好写的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查询界面出来之后软件感觉瞬间成型了一半，这几天还有一点让我学习的是如何协调后台程序的参数和gui界面的显示，我把原来的函数封装了几个类，另外写了一个主函数用来对各个界面以及后台功能函数的互相调用，这样运行逻辑更清晰。&lt;/p&gt;

&lt;p&gt;剩下的就是和界面加入主函数后互相进行调试。。。&lt;/p&gt;

&lt;p&gt;To be continued… :runner:&lt;/p&gt;</content><author><name>WUJIAJING</name></author><summary type="html">6月13日 列车信息模块 对车站名称、车站编号进行获取 通过分析12306查询响应找到jquery地址，构造正则表达式进行匹配获得字典 url = 'https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9055' r = requests.get(url) patter = u'([\u4e00-\u9fa5]+)\|([A-Z]+)' #unicode格式编码 result = dict(re.findall(patter, r.text)) 对字典键值对进行拆分获得车站名称和车站简写两个列表，构造函数方便互相取值 对得到的列车信息进行提取 trains = r.json()['data']['result'] 构造好请求地址后返回json对象，通过上面的格式获取raw_trains 将参数、raw_trains 传入TrainCollection类里，进行下一步提取 将得到的raw_trains用split(‘|‘)分割，得到列车信息列表，对比12306的js文件得到需要的信息 如果满足参数要求，构造生成器，返回parse_train_data函数处理好后的列车信息 得到列车信息列表，返回给tkinter输出 车票价格模块 同样分析12306网站响应，发现票价查询有两个页面，一个是单独查询所有票价，需要输入验证码，另外一个是在列车信息界面点击通过ajax请求获得点击的这行列车各个坐席的价格，验证码放到登录界面攻破，所以选择第二种方式，构造jquery请求网址，导入threading 模块，一次性获得查询趟次所有列车价格。 难点在于构造请求网址，同样通过分析js文件后获得列表对应的编号，主要是每趟列车的始发站和到达站格式为int形式，不同于初始请求的车站缩写。 6月14日 解决价格获取问题 ​ 昨天的价格获取实现不太友好，只是在终端输出。考虑到需要gui接收，必须封装成列表返回。本来以为是个小功能，结果发现并不简单。 ​ 利用for循环创建多线程获取到每列车次的价格后需要添加到类属性列表中，首先排除掉join方法，因为GIL的问题，当车次过多时严重超时，等待时间过长，考虑lock互斥锁。为了能一次性返回整合好的价格列表和车次余票信息（两个列表），必须让主进程等待价格列表获取完全，引入self.train_num初始化为0，查询一次+1，循环判断当数量等于用户查询的车次类型的数量时，获取成功，return两个列表。 while 1: if len(self.prices) == self.train_num: print('查询趟次:', len(self.prices)) return result, self.prices 综合对比过后，这是时间最短的一种方法，但当车次过多时等待时长还是较多。考虑tkinter实现多进程接收数据，让主菜单不至于卡死。 在开发到票价查询时，因为多次请求api，发现12306做了反爬机制会返回403错误，所以要完善查询功能还待进一步学习代理技术。 6月20日 近期总结 端午节过完了，后台程序也写得差不多了，写一下遇到的坑 排除了上次写的一次获取所有价格方案，（虽然多线程那里搞出来的时候还挺开心的，但是全部扔掉）决定在界面中实现用户点击单次列车进行价格查询，性能更高，程序更稳定。 登录模块 验证码 由于12306验证码过于变态，涉及到机器学习进行图片验证，所以直接请求验证码接口进行用户本地验证 创建8个本地列表坐标，获取用户选择的图片后将构造好的坐标与用户名密码一起发送给登录接口 登录验证 用fiddler抓包，居然有f12获取不到的数据，发现12306对用户名密码有两次验证， 用第一次请求https://kyfw.12306.cn/passport/web/auth/uamtk得到的apptk发送给https://kyfw.12306.cn/otn/uamauthclient,登录验证成功 订票购票模块 订票功能 登录查票之后点击预订按钮进行抓包分析，发现需要构造一个带sec字符串的json对象，这个sec串是在查询界面请求到的列车信息里的下标为0的元素，为了实现预订请求，把查询列车信息模块进行调整，传给界面的时候将整个分割后的data_list作为参数传递，方便订票时获取对应信息。 这里还需要当日的日期，格式按照0000-00-00，所以用到了time模块下的strftime,localtime对time.time()进行格式化 获取余票信息 这一块考察对页面获取到的信息进行筛选能力，多处用到正则， 其中余票数量让我最纠结，最后通过下列代码成功得到需要的数据 ticket_num = re.findall(r&quot;\w+num\':\'[1-9]\d*\'&quot;, res) 正则真的是，神器 剩下的就是依次请求接口获取下个接口需要的数据，也没什么好写的 查询界面出来之后软件感觉瞬间成型了一半，这几天还有一点让我学习的是如何协调后台程序的参数和gui界面的显示，我把原来的函数封装了几个类，另外写了一个主函数用来对各个界面以及后台功能函数的互相调用，这样运行逻辑更清晰。 剩下的就是和界面加入主函数后互相进行调试。。。 To be continued… :runner:</summary></entry><entry><title type="html">fluent python笔记</title><link href="http://localhost:4000/python/2018/06/07/fluntpython-note/" rel="alternate" type="text/html" title="fluent python笔记" /><published>2018-06-07T08:14:39+08:00</published><updated>2018-06-07T08:14:39+08:00</updated><id>http://localhost:4000/python/2018/06/07/fluntpython-note</id><content type="html" xml:base="http://localhost:4000/python/2018/06/07/fluntpython-note/">&lt;h1 id=&quot;数据类型&quot;&gt;数据类型&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bool&quot;&gt;bool&lt;/h3&gt;
&lt;p&gt;bool(x) 的背后是调用x.&lt;strong&gt;bool&lt;/strong&gt;() 的结果；如果不存在 &lt;strong&gt;bool&lt;/strong&gt; 方法，那么 bool(x) 会尝试调用 x.&lt;strong&gt;len&lt;/strong&gt;()。若返回 0，则 bool 会返回 False；否则返回True。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;bool&amp;gt; __bool__&amp;gt;__len__&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;collectionsnamedtuple&quot;&gt;collections.namedtuple&lt;/h3&gt;
&lt;p&gt;自 Python 2.6 开始，namedtuple 就加入到 Python 里，用以构建只有少数属性但是没有方法的对象，比如数据库条目。&lt;/p&gt;

&lt;h1 id=&quot;序列数组&quot;&gt;序列数组&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;序列&quot;&gt;序列&lt;/h3&gt;

&lt;p&gt;容器序列&lt;/p&gt;

&lt;p&gt;　　list、tuple 和 collections.deque 这些序列能存放不同类型的数据。&lt;/p&gt;

&lt;p&gt;扁平序列&lt;/p&gt;

&lt;p&gt;　　str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。&lt;/p&gt;

&lt;p&gt;容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。&lt;/p&gt;

&lt;p&gt;可变序列（仅限数组）&lt;/p&gt;

&lt;p&gt;　　list、bytearray、array.array、collections.deque 和memoryview。&lt;/p&gt;

&lt;p&gt;不可变序列&lt;/p&gt;

&lt;p&gt;　　tuple、str 和 bytes。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/12502239-64aa498350f3f65a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;关于迭代器和生成器&quot;&gt;关于迭代器和生成器：&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007208388&quot;&gt;白话解释迭代器和生成器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;迭代器：含__next__()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;可迭代：含__iter__()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;生成器：yield 或 ( 推导式 )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;l=[0, 1, 20, 11, 5, 22, 9]

l[2:5] = 100 ➊

&amp;gt;  Traceback (most recent call last):File &quot;&quot;, line 1,
&amp;gt;  in*TypeError:can only assign an iterable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;➊如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。&lt;/p&gt;

&lt;h3 id=&quot;初始化多维列表&quot;&gt;初始化多维列表&lt;/h3&gt;

&lt;p&gt;错误用法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; my_list = [[]] * 3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;初始化得到同一个列表的引用*3&lt;/p&gt;

&lt;p&gt;正确用法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; l=[[''] * 3 for i in range(3)]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;总结：注意对象的引用是否变化&lt;/p&gt;

&lt;h3 id=&quot;关于序列的增量赋值运算&quot;&gt;关于序列的增量赋值运算&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;+=&lt;/strong&gt; 类似于 &lt;strong&gt;*=&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;程序先调用__iadd__，如果没找到，就调用__add__方法，&lt;/p&gt;

&lt;p&gt;！可变序列+=后，变量名不会被关联到新的对象，不可变序列因为不存在增量赋值运算，调用__add__后创建新变量赋值给原不可变序列。（str 是一个例外，因为对字符串做 += 实在是太普遍了，所以 CPython 对它做了优化。为 str初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作）&lt;/p&gt;

&lt;p&gt;栗子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/12502239-7efb570c5a3e337e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/12502239-770fd0c03a1d66f2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;元组&quot;&gt;元组&lt;/h3&gt;
&lt;p&gt;栗子：&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;抛出异常同时修改t&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、不要把可变对象放在元组里面。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;字典和集合&quot;&gt;字典和集合&lt;/h1&gt;

&lt;h3 id=&quot;创建字典的不同方式&quot;&gt;创建字典的不同方式：&lt;/h3&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;three&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'one'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'two'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'three'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'one'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'two'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'three'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'two'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'one'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'three'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'three'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'one'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'two'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;减少字典查询次数&quot;&gt;减少字典查询次数：&lt;/h3&gt;
&lt;p&gt;这样写
&lt;code class=&quot;highlighter-rouge&quot;&gt;my_dict.setdefault(key, []).append(new_value)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;获取单词的出现情况列表，如果单词不存在，把单词和一个空列表放进映射，然后返回这个空列表，这样就能在不进行第二次查找的情况下更新列表了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;跟这样写：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;my_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;my_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用 setdefault 只需要一次就可以完成整个操作。&lt;/p&gt;

&lt;h3 id=&quot;defaultdict&quot;&gt;defaultdict&lt;/h3&gt;
&lt;p&gt;defaultdict 里的default_factory只会在__getitem__里被调用，在其他的方法里完全不会发挥作用。比如，dd 是个 defaultdict，k 是个找不到的键， dd[k] 这个表达式会调用 default_factory 的__getitem__ 方法创造某个默认值，而 dd.get(k) 则会返回 None。&lt;/p&gt;

&lt;h3 id=&quot;__missing__&quot;&gt;__missing__&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StrKeyDict0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;➊&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__missing__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;➋&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;KeyError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;➌&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;➍&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;KeyError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;➎&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__contains__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;➏&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;❶ StrKeyDict0 继承了 dict。
❷ 如果找不到的键本身就是字符串，那就抛出 KeyError 异常。
❸ 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。
❹ get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会。
❺ 如果抛出 KeyError，那么说明 __missing__ 也失败了，于是返回default。
❻ 先按照传入键的原本的值来查找（我们的映射类型中可能含有非字符串的键），如果没找到，再用 str() 方法把键转换成字符串再查找一次。&lt;/p&gt;

&lt;h3 id=&quot;集合&quot;&gt;集合&lt;/h3&gt;

&lt;p&gt;像 {1, 2, 3} 这种字面量句法相比于构造方法（set([1, 2, 3])）要更快且更易读。后者的速度要慢一些&lt;/p&gt;

&lt;h3 id=&quot;dict和set的背后&quot;&gt;dict和set的背后&lt;/h3&gt;

&lt;p&gt;背后的散列表&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Python 里的 dict 和 set 的效率有多高？&lt;/li&gt;
  &lt;li&gt;为什么它们是无序的？&lt;/li&gt;
  &lt;li&gt;为什么并不是所有的 Python 对象都可以当作 dict 的键或 set 里的元素？&lt;/li&gt;
  &lt;li&gt;为什么 dict 的键和 set 元素的顺序是跟据它们被添加的次序而定的，以及为什么在映射对象的生命周期中，这个顺序并不是一成不变的？&lt;/li&gt;
  &lt;li&gt;为什么不应该在迭代循环 dict 或是 set 的同时往里添加元素？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;散列表看不懂，以后再看&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To be continued… :runner:&lt;/p&gt;</content><author><name>WUJIAJING</name></author><summary type="html">数据类型 bool bool(x) 的背后是调用x.bool() 的结果；如果不存在 bool 方法，那么 bool(x) 会尝试调用 x.len()。若返回 0，则 bool 会返回 False；否则返回True。 bool&amp;gt; __bool__&amp;gt;__len__ collections.namedtuple 自 Python 2.6 开始，namedtuple 就加入到 Python 里，用以构建只有少数属性但是没有方法的对象，比如数据库条目。 序列数组 序列 容器序列 　　list、tuple 和 collections.deque 这些序列能存放不同类型的数据。 扁平序列 　　str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。 容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。 可变序列（仅限数组） 　　list、bytearray、array.array、collections.deque 和memoryview。 不可变序列 　　tuple、str 和 bytes。 关于迭代器和生成器： 白话解释迭代器和生成器 迭代器：含__next__() 可迭代：含__iter__() 生成器：yield 或 ( 推导式 ) l=[0, 1, 20, 11, 5, 22, 9] l[2:5] = 100 ➊ &amp;gt; Traceback (most recent call last):File &quot;&quot;, line 1, &amp;gt; in*TypeError:can only assign an iterable ➊如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。 初始化多维列表 错误用法 my_list = [[]] * 3 初始化得到同一个列表的引用*3 正确用法： l=[[''] * 3 for i in range(3)] 总结：注意对象的引用是否变化 关于序列的增量赋值运算 += 类似于 *= 程序先调用__iadd__，如果没找到，就调用__add__方法， ！可变序列+=后，变量名不会被关联到新的对象，不可变序列因为不存在增量赋值运算，调用__add__后创建新变量赋值给原不可变序列。（str 是一个例外，因为对字符串做 += 实在是太普遍了，所以 CPython 对它做了优化。为 str初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作） 栗子： 元组 栗子： &amp;gt;&amp;gt;&amp;gt; t = (1, 2, [30, 40]) &amp;gt;&amp;gt;&amp;gt; t[2] += [50, 60] 抛出异常同时修改t 总结： 1、不要把可变对象放在元组里面。 2、增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。 3、查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。 字典和集合 创建字典的不同方式： &amp;gt;&amp;gt;&amp;gt; a = dict(one=1, two=2, three=3) &amp;gt;&amp;gt;&amp;gt; b = {'one': 1, 'two': 2, 'three': 3} &amp;gt;&amp;gt;&amp;gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3])) &amp;gt;&amp;gt;&amp;gt; d = dict([('two', 2), ('one', 1), ('three', 3)]) &amp;gt;&amp;gt;&amp;gt; e = dict({'three': 3, 'one': 1, 'two': 2}) &amp;gt;&amp;gt;&amp;gt; a == b == c == d == e True 减少字典查询次数： 这样写 my_dict.setdefault(key, []).append(new_value) 获取单词的出现情况列表，如果单词不存在，把单词和一个空列表放进映射，然后返回这个空列表，这样就能在不进行第二次查找的情况下更新列表了。 跟这样写： if key not in my_dict: my_dict[key] = [] my_dict[key].append(new_value) 二者的效果是一样的，只不过后者至少要进行两次键查询——如果键不存在的话，就是三次，用 setdefault 只需要一次就可以完成整个操作。 defaultdict defaultdict 里的default_factory只会在__getitem__里被调用，在其他的方法里完全不会发挥作用。比如，dd 是个 defaultdict，k 是个找不到的键， dd[k] 这个表达式会调用 default_factory 的__getitem__ 方法创造某个默认值，而 dd.get(k) 则会返回 None。 __missing__ class StrKeyDict0(dict): ➊ def __missing__(self, key): if isinstance(key, str): ➋ raise KeyError(key) return self[str(key)] ➌ def get(self, key, default=None): try: return self[key] ➍ except KeyError: return default ➎ def __contains__(self, key): return key in self.keys() or str(key) in self.keys() ➏ ❶ StrKeyDict0 继承了 dict。 ❷ 如果找不到的键本身就是字符串，那就抛出 KeyError 异常。 ❸ 如果找不到的键不是字符串，那么把它转换成字符串再进行查找。 ❹ get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会。 ❺ 如果抛出 KeyError，那么说明 __missing__ 也失败了，于是返回default。 ❻ 先按照传入键的原本的值来查找（我们的映射类型中可能含有非字符串的键），如果没找到，再用 str() 方法把键转换成字符串再查找一次。 集合 像 {1, 2, 3} 这种字面量句法相比于构造方法（set([1, 2, 3])）要更快且更易读。后者的速度要慢一些 dict和set的背后 背后的散列表 Python 里的 dict 和 set 的效率有多高？ 为什么它们是无序的？ 为什么并不是所有的 Python 对象都可以当作 dict 的键或 set 里的元素？ 为什么 dict 的键和 set 元素的顺序是跟据它们被添加的次序而定的，以及为什么在映射对象的生命周期中，这个顺序并不是一成不变的？ 为什么不应该在迭代循环 dict 或是 set 的同时往里添加元素？ 散列表看不懂，以后再看 To be continued… :runner:</summary></entry><entry><title type="html">ok</title><link href="http://localhost:4000/2018/06/07/ok/" rel="alternate" type="text/html" title="ok" /><published>2018-06-07T08:14:39+08:00</published><updated>2018-06-07T08:14:39+08:00</updated><id>http://localhost:4000/2018/06/07/ok</id><content type="html" xml:base="http://localhost:4000/2018/06/07/ok/">&lt;p&gt;我的猫在我的键盘上走了一圈tuniocxzubhlkn214890o0ihfclknaeopj*(y732iknhdvgpoanlkn214ijoxcvn,asdfklj314
舍不得删它&lt;/p&gt;

&lt;p&gt;:ok_hand:&lt;/p&gt;</content><author><name>WUJIAJING</name></author><category term="不容易" /><summary type="html">我的猫在我的键盘上走了一圈tuniocxzubhlkn214890o0ihfclknaeopj*(y732iknhdvgpoanlkn214ijoxcvn,asdfklj314 舍不得删它 :ok_hand:</summary></entry><entry><title type="html">Among School Children</title><link href="http://localhost:4000/python/2018/06/02/AmongSchoolChildren/" rel="alternate" type="text/html" title="Among School Children" /><published>2018-06-02T00:14:39+08:00</published><updated>2018-06-02T00:14:39+08:00</updated><id>http://localhost:4000/python/2018/06/02/AmongSchoolChildren</id><content type="html" xml:base="http://localhost:4000/python/2018/06/02/AmongSchoolChildren/">&lt;h3 id=&quot;vi&quot;&gt;VI&lt;/h3&gt;

&lt;p&gt;Plato thought nature but a spume that plays&lt;/p&gt;

&lt;p&gt;Upon a ghostly paradigm of things;&lt;/p&gt;

&lt;p&gt;Solider Aristotle played the taws &lt;/p&gt;

&lt;p&gt;Upon the bottom of a king of kings;&lt;/p&gt;

&lt;p&gt;World-famous golden-thighed Pythagoras &lt;/p&gt;

&lt;p&gt;Fingered upon a fiddle-stick or strings&lt;/p&gt;

&lt;p&gt;What a star sang and careless Muses heard:&lt;/p&gt;

&lt;p&gt;Old clothes upon old sticks to scare a bird.&lt;/p&gt;</content><author><name>WUJIAJING</name></author><summary type="html">VI Plato thought nature but a spume that plays Upon a ghostly paradigm of things; Solider Aristotle played the taws  Upon the bottom of a king of kings; World-famous golden-thighed Pythagoras  Fingered upon a fiddle-stick or strings What a star sang and careless Muses heard: Old clothes upon old sticks to scare a bird.</summary></entry></feed>