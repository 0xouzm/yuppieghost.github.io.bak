<h1 id="python基础">Python基础</h1>

<h2 id="基础语法">基础语法</h2>

<ol>
  <li>
    <p>a=a^b</p>

    <p>b=b^a</p>

    <p>a=a^b</p>
  </li>
  <li>
    <p>修改不可变类型 TypeError</p>
  </li>
  <li>
    <p>print 调用 sys.stdout.write方法</p>
  </li>
  <li>
    <p>小内存读取大文件：</p>

    <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_lines</span><span class="p">():</span>
    <span class="n">l</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'file.txt'</span><span class="p">,</span><span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">(</span><span class="mi">60000</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">l</span>
</code></pre>
    </div>

    <p>通过<strong>生成器</strong>，分多次读取，每次读取数量相对少的数据进行处理</p>

    <p>要考虑的问题： 分批读入数据要记录每次读入数据的位置；分批每次读入数据的大小，太小会在读取操作上耗费过多时间。</p>
  </li>
  <li>
    <p>read、readline、readlines的区别？</p>

    <p>read:读取整个文件</p>

    <p>readline:读取下一行，使用生成器方法</p>

    <p>readlines:读取整个文件到一个迭代器供我们遍历（可指定行数）</p>
  </li>
  <li>
    <p>linux</p>

    <ul>
      <li>这个函数接收文件夹的路径作为输入参数</li>
      <li>返回该文件夹中文件的路径</li>
      <li>以及其包含文件夹中文件的路径</li>
    </ul>

    <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_directory_contents</span><span class="p">(</span><span class="n">sPath</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="k">for</span> <span class="n">sChild</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">sPath</span><span class="p">):</span>
        <span class="n">sChildPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sPath</span><span class="p">,</span><span class="n">sChild</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">sChildPath</span><span class="p">):</span>
            <span class="n">print_directory_contents</span><span class="p">(</span><span class="n">sChildPath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">sChildPath</span><span class="p">)</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>常用的Python标准库：</p>

    <ul>
      <li>os</li>
      <li>time</li>
      <li>random</li>
      <li>pymysql</li>
      <li>threading</li>
      <li>multiprocessing</li>
      <li>queue</li>
    </ul>
  </li>
  <li>
    <p>浅拷贝（shallow copy）</p>

    <p>浅拷贝会创建新对象，其内容非原对象本身的引用，而是原对象内第一层对象的引用。</p>

    <p>浅拷贝有三种形式：</p>

    <ul>
      <li>
        <p>切片操作: b=a[:] or b = [x for x in a]</p>
      </li>
      <li>
        <p>工厂模式: b=list(a)</p>
      </li>
      <li>
        <p>copy: b=copy.copy(a)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>os模块常见方法</p>

    <ul>
      <li>
        <p>os.remove()</p>
      </li>
      <li>
        <p>os.rename()</p>
      </li>
      <li>
        <p>os.walk()</p>
      </li>
      <li>
        <p>os.chdir()</p>
      </li>
      <li>
        <p>os.mkdir/makedirs</p>
      </li>
      <li>
        <p>os.rmdir/removedirs</p>
      </li>
      <li>
        <p>os.listdir()</p>
      </li>
      <li>
        <p>os.getcwd()</p>
      </li>
      <li>
        <p>os.chmod()</p>
      </li>
      <li>
        <p>os.path.basename()</p>
      </li>
      <li>
        <p>os.path.dirname()</p>
      </li>
      <li>
        <p>os.path.join()</p>
      </li>
      <li>
        <p>os.path.split()</p>
      </li>
      <li>
        <p>os.path.getsize()</p>
      </li>
      <li>
        <p>os.path.exists()</p>
      </li>
      <li>
        <p>os.path.isabs()</p>
      </li>
      <li>
        <p>os.path.isdir()</p>
      </li>
      <li>
        <p>os.path.isfile()</p>
      </li>
    </ul>
  </li>
  <li>
    <p>sys 常用方法</p>

    <ul>
      <li>sys.argv</li>
      <li>sys.modules.keys()</li>
      <li>sys.exc_info()</li>
      <li>sys.exit(n)</li>
      <li>sys.version</li>
      <li>sys.maxint</li>
      <li>sys.maxunicode</li>
      <li>sys.modules</li>
      <li>sys.path</li>
      <li>sys.platform</li>
      <li>sys.stdout</li>
      <li>sys.stdin</li>
      <li>sys.stderr</li>
      <li>sys.exc_clear</li>
      <li>sys.exec_prefix</li>
      <li>sys.byteorder</li>
      <li>sys.copyright</li>
      <li>sys.api_version</li>
      <li>sys.version_info</li>
    </ul>
  </li>
  <li>
    <p>Python 是强语言类型还是弱语言类型？</p>

    <p>Python 是强类型的动态脚本语言。</p>

    <p><strong>强类型：不允许不同类型相加。</strong></p>

    <p><strong>动态：不使用显示数据类型声明，确定一个变量的类型是第一次给它赋值的时候。</strong></p>

    <p><strong>脚本语言： 一般也是解释性语言，运行代码只需要一个解释器，不需要编译。</strong></p>
  </li>
</ol>

